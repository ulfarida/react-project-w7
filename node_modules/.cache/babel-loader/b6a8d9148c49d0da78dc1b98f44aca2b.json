{"ast":null,"code":"function n(n, t) {\n  for (var r in t) n[r] = t[r];\n\n  return n;\n}\n\nexport default function (t) {\n  var r = [];\n\n  function u(n) {\n    for (var t = [], u = 0; u < r.length; u++) r[u] === n ? n = null : t.push(r[u]);\n\n    r = t;\n  }\n\n  function e(u, e, f) {\n    t = e ? u : n(n({}, t), u);\n\n    for (var i = r, o = 0; o < i.length; o++) i[o](t, f);\n  }\n\n  return t = t || {}, {\n    action: function (n) {\n      function r(t) {\n        e(t, !1, n);\n      }\n\n      return function () {\n        for (var u = arguments, e = [t], f = 0; f < arguments.length; f++) e.push(u[f]);\n\n        var i = n.apply(this, e);\n        if (null != i) return i.then ? i.then(r) : r(i);\n      };\n    },\n    setState: e,\n    subscribe: function (n) {\n      return r.push(n), function () {\n        u(n);\n      };\n    },\n    unsubscribe: u,\n    getState: function () {\n      return t;\n    }\n  };\n}","map":{"version":3,"sources":["../src/util.js","../src/index.js"],"names":["assign","obj","props","let","i","state","listeners","unsubscribe","listener","out","length","push","setState","update","overwrite","action","currentListeners","apply","result","args","arguments","ret","this","then","subscribe","getState"],"mappings":"AAyBO,SAASA,CAAT,CAAgBC,CAAhB,EAAqBC,CAArB,EAAqBA;AAAAA,OACtBC,IAAIC,CADkBF,IACbA,CADaA,EACND,CAAAA,CAAIG,CAAJH,CAAAA,GAASC,CAAAA,CAAME,CAANF,CAATD;;AAAeG,SAC7BH,CAD6BG;AAC7BH;;AAAAA,eCdO,UAAqBI,CAArB,EAAqBA;AAAAA,MAC/BC,CAAAA,GAAY,EADmBD;;AACnB,WAGPE,CAHO,CAGKC,CAHL,EAGKA;AAAAA,SAAAA,IAChBC,CAAAA,GAAM,EADUD,EAEXJ,CAAAA,GAAE,CAFSI,EAENJ,CAAAA,GAAEE,CAAAA,CAAUI,MAFNF,EAEcJ,CAAAA,EAFdI,EAGfF,CAAAA,CAAUF,CAAVE,CAAAA,KAAeE,CAAfF,GACHE,CAAAA,GAAW,IADRF,GAIHG,CAAAA,CAAIE,IAAJF,CAASH,CAAAA,CAAUF,CAAVE,CAATG,CAJGH;;AAOLA,IAAAA,CAAAA,GAAYG,CAAZH;AAAYG;;AAAAA,WAGJG,CAHIH,CAGKI,CAHLJ,EAGaK,CAHbL,EAGwBM,CAHxBN,EAGwBM;AACpCV,IAAAA,CAAAA,GAAQS,CAAAA,GAAYD,CAAZC,GAAqBd,CAAAA,CAAOA,CAAAA,CAAO,EAAPA,EAAWK,CAAXL,CAAPA,EAA0Ba,CAA1Bb,CAA7BK;;AAAuDQ,SAAAA,IACnDG,CAAAA,GAAmBV,CADgCO,EAE9CT,CAAAA,GAAE,CAF4CS,EAEzCT,CAAAA,GAAEY,CAAAA,CAAiBN,MAFsBG,EAEdT,CAAAA,EAFcS,EAETG,CAAAA,CAAiBZ,CAAjBY,CAAAA,CAAoBX,CAApBW,EAA2BD,CAA3BC;AAA2BD;;AAAAA,SAlB1EV,CAAAA,GAAQA,CAAAA,IAAS,EAAjBA,EAAiB;AAmChBU,IAAAA,MAAAA,EAAAA,UAAOA,CAAPA,EAAOA;AAAAA,eACGE,CADHF,CACSG,CADTH,EACSG;AACdN,QAAAA,CAAAA,CAASM,CAATN,EAASM,CAAQ,CAAjBN,EAAwBG,CAAxBH,CAAAA;AAAwBG;;AAAAA,aAIlB,YAAA;AAAA,aAAA,IAAA,CAAA,GAAA,SAAA,EACFI,CAAAA,GAAO,CAACd,CAAD,CADL,EAEGD,CAAAA,GAAE,CAFL,EAEQA,CAAAA,GAAEgB,SAAAA,CAAUV,MAFpB,EAE4BN,CAAAA,EAF5B,EAEiCe,CAAAA,CAAKR,IAALQ,CAAUC,CAAAA,CAAUhB,CAAVgB,CAAVD;;AAAoBf,YACvDiB,CAAAA,GAAMN,CAAAA,CAAOE,KAAPF,CAAaO,IAAbP,EAAmBI,CAAnBJ,CADiDX;AAC9Be,YACpB,QAALE,CADyBF,EACzBE,OACCA,CAAAA,CAAIE,IAAJF,GAAiBA,CAAAA,CAAIE,IAAJF,CAASJ,CAATI,CAAjBA,GACGJ,CAAAA,CAAMI,CAANJ,CAFJI;AAEUA,OAVUN;AAUVM,KA/CA;AA+CAA,IAAAA,QAAAA,EAUhBT,CAzDgB;AAgEhBY,IAAAA,SAAAA,EAAAA,UAAUhB,CAAVgB,EAAUhB;AAAAA,aACTF,CAAAA,CAAUK,IAAVL,CAAeE,CAAfF,GAAeE,YAAAA;AACAD,QAAAA,CAAAA,CAAYC,CAAZD,CAAAA;AAAYC,OAFlBA;AAEkBA,KAlEZ;AAkEYA,IAAAA,WAAAA,EAQ5BD,CA1EgB;AAgFhBkB,IAAAA,QAAAA,EAAAA,YAAAA;AAAAA,aACQpB,CADRoB;AACQpB;AAjFQ,GAkByDU;AA+DjEV","sourcesContent":["// Bind an object/factory of actions to the store and wrap them.\nexport function mapActions(actions, store) {\n\tif (typeof actions==='function') actions = actions(store);\n\tlet mapped = {};\n\tfor (let i in actions) {\n\t\tmapped[i] = store.action(actions[i]);\n\t}\n\treturn mapped;\n}\n\n\n// select('foo,bar') creates a function of the form: ({ foo, bar }) => ({ foo, bar })\nexport function select(properties) {\n\tif (typeof properties==='string') properties = properties.split(/\\s*,\\s*/);\n\treturn state => {\n\t\tlet selected = {};\n\t\tfor (let i=0; i<properties.length; i++) {\n\t\t\tselected[properties[i]] = state[properties[i]];\n\t\t}\n\t\treturn selected;\n\t};\n}\n\n\n// Lighter Object.assign stand-in\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn obj;\n}\n","import { assign } from './util';\n\n/**\n * Creates a new store, which is a tiny evented state container.\n * @name createStore\n * @param {Object} [state={}]\t\tOptional initial state\n * @returns {store}\n * @example\n * let store = createStore();\n * store.subscribe( state => console.log(state) );\n * store.setState({ a: 'b' });   // logs { a: 'b' }\n * store.setState({ c: 'd' });   // logs { a: 'b', c: 'd' }\n */\nexport default function createStore(state) {\n\tlet listeners = [];\n\tstate = state || {};\n\n\tfunction unsubscribe(listener) {\n\t\tlet out = [];\n\t\tfor (let i=0; i<listeners.length; i++) {\n\t\t\tif (listeners[i]===listener) {\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.push(listeners[i]);\n\t\t\t}\n\t\t}\n\t\tlisteners = out;\n\t}\n\n\tfunction setState(update, overwrite, action) {\n\t\tstate = overwrite ? update : assign(assign({}, state), update);\n\t\tlet currentListeners = listeners;\n\t\tfor (let i=0; i<currentListeners.length; i++) currentListeners[i](state, action);\n\t}\n\n\t/**\n\t * An observable state container, returned from {@link createStore}\n\t * @name store\n\t */\n\n\treturn /** @lends store */ {\n\n\t\t/**\n\t\t * Create a bound copy of the given action function.\n\t\t * The bound returned function invokes action() and persists the result back to the store.\n\t\t * If the return value of `action` is a Promise, the resolved value will be used as state.\n\t\t * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n\t\t * @returns {Function} boundAction()\n\t\t */\n\t\taction(action) {\n\t\t\tfunction apply(result) {\n\t\t\t\tsetState(result, false, action);\n\t\t\t}\n\n\t\t\t// Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n\t\t\treturn function() {\n\t\t\t\tlet args = [state];\n\t\t\t\tfor (let i=0; i<arguments.length; i++) args.push(arguments[i]);\n\t\t\t\tlet ret = action.apply(this, args);\n\t\t\t\tif (ret!=null) {\n\t\t\t\t\tif (ret.then) return ret.then(apply);\n\t\t\t\t\treturn apply(ret);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Apply a partial state object to the current state, invoking registered listeners.\n\t\t * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n\t\t * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n\t\t */\n\t\tsetState,\n\n\t\t/**\n\t\t * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n\t\t * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n\t\t * @returns {Function} unsubscribe()\n\t\t */\n\t\tsubscribe(listener) {\n\t\t\tlisteners.push(listener);\n\t\t\treturn () => { unsubscribe(listener); };\n\t\t},\n\n\t\t/**\n\t\t * Remove a previously-registered listener function.\n\t\t * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n\t\t * @function\n\t\t */\n\t\tunsubscribe,\n\n\t\t/**\n\t\t * Retrieve the current state object.\n\t\t * @returns {Object} state\n\t\t */\n\t\tgetState() {\n\t\t\treturn state;\n\t\t}\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}